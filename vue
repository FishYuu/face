1、v-model的原理
  绑定数据并且监听数据改变。
  vue的数据双向绑定的原理就是用的Object.defineProperty这个方法，里面定义了setter和getter方法，通过观察者模式（发布订阅模式）来监听数据的变化，从而做相应的逻辑处理。
 
2、Vue的风格指南
  （1）使用v-for时记得加key，可以快速定位到需要更新的DOM节点，提高效率。
  （2）永远不要把 v-if 和 v-for 同时用在同一个元素上。提高渲染效率 。
  （3）优先通过 Vuex 管理全局状态，而不是通过 this.$root 或一个全局事件总线 。
  （4）组件的 data 必须是一个函数。

3、子组件访问父组件的3种方式
  （1）直接在子组件中通过this.$parent.event来调用父组件的方法 
  （2）在子组件里用$emit向父组件触发一个事件，父组件监听这个事件 
  （3）父组件把方法传入子组件中，在子组件里直接调用这个方法
  
4、父组件中怎么接受子组件的多个参数
  子组件向父组件发射方法this.$emit("名称",data) data为一个对象，对象内可以封装自己想传递的任何数据。父组件接收方法，解封取到自己需要的数据。

5、父组件怎么访问到子组件的实例或者子元素？
  在引用的子组件标签上加 ref属性如ref="xxxx"，在父组件通过this.$refs.xxxx.子组件方法名或者 this.$children.子组件的方法名来调用。
  
6、v-once和v-pre的使用场景
  v-once: 只渲染元素和组件一次，随后的重新渲染，视图不发生更新,元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。
  v-pre: 某个元素如果添加v-pre指令，内部的元素会被vue直接跳过，不过渲染 。将来有可能有一大段的文本，我很明确的知道这段文本是不需要vue来处理

7、定时器的使用和销毁
  mounted:
    mounted() {
      this.timer = setInterval(() => {
        setTimeout(this.getAllMethod, 0)
      }, 1000*30)
     }
  destroyed:
    destroyed() {
      clearTimeout(this.timer);
      this.timer=null;
    }

8、vue中template有什么用？
  当做一个不可见的包裹元素，减少不必要的DOM元素，整个结构会更加清晰。 template不会出现在dom结构中，经常和v-if搭配使用。

9、nextTick原理
  用法：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 Vue官网提到DOM的更新是异步执行的，只要数据发生变化，将会开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中一次。
  简单来说，就是当数据发生变化时，视图不会立即更新，而是等到同一事件循环中所有数据变化完成之后，再统一更新视图。

10、v-cloak的理解使用
  在网络不好或加载数据过大的情况下，页面在渲染的过程会闪烁Mustache 标签：{{}}
  为了用户有更好的优化体验，Vue加入了延缓响应的指令v-cloak,在与css:[v-cloak] { display: none } 的配合下，可以隐藏未编译 Mustache 的标签直到实例准备完毕，v-cloak属性才会被自动去除，对应的标签也才可见了。

1、vue生命周期总共有几个阶段？
  （1）创建 
      1、beforeCreate：这个阶段实例已经初始化，只是数据观察与事件机制尚未形成，不能获取DOM节点（没有data，没有el） 
      使用场景：因为此时data和methods都拿不到，所以通常在实例以外使用 
      2、created：实例已经创建，仍然不能获取DOM节点（有data，没有el） 
      使用场景：模板渲染成html前调用，此时可以获取data和methods，so 可以初始化某些属性值，然后再渲染成视图，异步操作可以放在这里。
  （2）载入 
      1、beforeMount：是个过渡阶段，此时依然获取不到具体的DOM节点，但是vue挂载的根节点已经创建（有data，有el） 
      2、mounted：数据和DOM都已经被渲染出来了 使用场景：模板渲染成html后调用，通常是初始化页面完成后再对数据和DOM做一些操作，需要操作DOM的方法可以放在这里
  （3）三、更新 
      1、beforeUpdate：检测到数据更新时，但在DOM更新前执行 
      2、updated：更新结束后执行 使用场景：需要对数据更新做统一处理的；如果需要区分不同的数据更新操作可以使用$nextTick
  （4）四、销毁 
      1、beforeDestroy：当要销毁vue实例时，在销毁前执行 
      2、destroyed：销毁vue实例时执行

11、computed 和 watch 的区别
  computed：计算属性
    计算属性是由data中的已知值，得到的一个新值。
    这个新值只会根据已知值的变化而变化，其他不相关的数据的变化不会影响该新值。
    计算属性不在data中，计算属性新值的相关已知值在data中。
    别人变化影响我自己。
  watch：监听数据的变化
    监听data中数据的变化
    监听的数据就是data中的已知值
    我的变化影响别人
  1.watch擅长处理的场景：一个数据影响多个数据
  2.computed擅长处理的场景：一个数据受多个数据影响
  功能上：computed是计算属性，也就是依赖其它的属性计算所得出最后的值。watch是去监听一个值的变化，然后执行相对应的函数
  使用上：computed中的函数必须要用return返回；watch的回调里面会传入监听属性的新旧值，通过这两个值可以做一些特定的操作，不是必须要用return
  性能上：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调
  场景上：computed：当一个属性受多个属性影响的时候，例子：购物车商品结算；watch：当一条数据影响多条数据的时候，例子：搜索框
  
12、v-if、v-show、v-html 的原理是什么，它是如何封装的？
  v-if: 调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染
  v-show: 生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display；
  v-html: 先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值
  v-if和v-show的区别
    v-if是惰性的，只是值为false就不会加载对应元素，为true才动态加载对应元素
    v-show:是无论为true和为false都会加载对应html代码，但为false时用display:none隐藏不在页面显示，但为true时页面上用display:block显示其效果
    适用场景：切换频繁的场合用v-show,切换不频繁的场合用v-if
 
 13、vue最大特点是什么或者说vue核心是什么
    vue最大特点我感觉就是“组件化“和”数据驱动“
    组件化就是可以将页面和页面中可复用的元素都看做成组件，写页面的过程，就是写组件，然后页面是由这些组件“拼接“起来的组件树
    数据驱动就是让我们只关注数据层，只要数据变化，页面（即视图层）会自动更新，至于如何操作dom，完全交由vue去完成，咱们只关注数据，数据变了，页面自动同步变化了，很方便
 
14、vue常用基本指令有哪些
  v-if：根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。
  v-show：根据表达式之真假值，切换元素的 display CSS 属性。
  v-for：循环指令，基于一个数组或者对象渲染一个列表，vue 2.0以上必须需配合 key值 使用。
  v-bind：动态地绑定一个或多个特性，或一个组件 prop 到表达式。
  v-on：用于监听指定元素的DOM事件，比如点击事件。绑定事件监听器。
  v-model：实现表单输入和应用状态之间的双向绑定
  v-pre：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。
  v-once：只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。

15、Vue常用的修饰符
  （1）v-on 指令常用修饰符：
    .stop - 调用 event.stopPropagation()，禁止事件冒泡。
    .prevent - 调用 event.preventDefault()，阻止事件默认行为。
    .capture - 添加事件侦听器时使用 capture 模式。
    .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。
    .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。
    .native - 监听组件根元素的原生事件。
    .once - 只触发一次回调。
    .left - (2.2.0) 只当点击鼠标左键时触发。
    .right - (2.2.0) 只当点击鼠标右键时触发。
    .middle - (2.2.0) 只当点击鼠标中键时触发。
    .passive - (2.3.0) 以 { passive: true } 模式添加侦听器
  （2）v-bind 指令常用修饰符：
    .prop - 被用于绑定 DOM 属性 (property)。(差别在哪里？)
    .camel - (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持)
    .sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。
  （3）v-model 指令常用修饰符：
    .lazy - 取代 input 监听 change 事件
    .number - 输入字符串转为数字
    .trim - 输入首尾空格过滤
   
16、vue组件通讯（即传值）有哪几种形式，分别是如何实现的
    vue组件通讯大致有三种：父传子，子传父，还有兄弟之间通讯
    第一种：父传子：主要通过props来实现的
			具体实现：父组件通过import引入子组件，并注册，在子组件标签上添加要传递的属性，子组件通过props接收，接收有两种形式一是通过数组形式[‘要接收的属性’ ]，二是通过对象形式{  }来接收，对象形式可以设置要传递的数据类型和默认值，而数组只是简单的接收
    第二种：子传父：主要通过$emit来实现
		   具体实现：子组件通过通过绑定事件触发函数，在其中设置this.$emit(‘要派发的自定义事件’，要传递的值)，$emit中有两个参数一是要派发的自定义事件，第二个参数是要传递的值
       然后父组件中,在这个子组件身上@派发的自定义事件,绑定事件触发的methods中的方法接受的默认值,就是传递过来的参数
    第三种：兄弟之间传值有两种方法：
		  方法一：通过event bus实现
		    具体实现:创建一个空的vue并暴露出去，这个作为公共的bus,即当作两个组件的桥梁，在两个兄弟组件中分别引入刚才创建的bus，在组件A中通过bus.$emit（’自定义事件名’，要发送的值）发送数据，在组件B中通过bus.$on（‘自定义事件名‘,function(v) { //v即为要接收的值 }）接收数据
      方法二：通过vuex实现
		    具体实现：vuex是一个状态管理工具，主要解决大中型复杂项目的数据共享问题，主要包括state,actions,mutations,getters和modules 5个要素，主要流程：组件通过dispatch到 actions，actions是异步操作，再actions中通过commit到mutations，mutations再通过逻辑操作改变state，从而同步到组件，更新其数据状态

17、 说一下你对vuex的理解：
  vuex是一个状态管理工具，主要解决大中型复杂项目的数据共享问题，主要包括state,actions,mutations,getters和modules 5个要素，
  主要流程：组件通过dispatch到 actions，actions是异步操作，再actions中通过commit到mutations，mutations再通过逻辑操作改变state，从而同步到组件，更新其数据状态,而getters相当于组件的计算属性对,组件中获取到的数据做提前处理的.再说到辅助函数的作用.
    
18、vuex如何实现数据持久化（即刷新后数据还保留）？
    第一种：利用H5的本地存储(localStorage,sessionStorage)
    第二种：利用第三方封装好的插件，例如：vuex-persistedstate
    第三种:使用vue-cookie插件来做存储
    第四种：可以把数据传递到后台，存储到数据库中，***比较耗费资源
    
19、vue优缺点？
    优点：
      轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb； 
      简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习； 
      双向数据绑定：保留了angular的特点，在数据操作方面更为简单； 
      组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势； 
      视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作； 
      虚拟DOM：dom操作是非常耗费性能的， 不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式； 
      运行速度更快:相比较与react而言，同样是操作虚拟dom，就性能而言，vue存在很大的优势。
    缺点：
      不支持IE8.0及其以下版本；
      入门快，但是高阶教程少；
      生态环境不如其他框架；
      社区不大；
    
20、Vue中双向数据绑定是如何实现的？
   vue 双向数据绑定是通过 数据劫持 结合 发布订阅模式的方式来实现的， 也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变； 
   核心：关于VUE双向数据绑定，其核心是 Object.defineProperty()方法。
    
21、vue 和 react 区别
  相同：
    1、都使用vdom；
    2、都提供了响应式和组件化的视图组件；
    3、核心都在UI层（比如路由，状态管理，数据请求交给其他库）；
    4、都是单向数据流；
    5、轻量级
  不同：
    1、vue 基于 html 的模板语法，react 是 jsx 语法，可以 html 和 js 混写；
    2、状态管理 vue 是 data，react 是 state 但是不能直接修改 state，需要 setState 方法；
    3、vue 使用 solt 插槽进行嵌套传递，react 使用 props.children 传递；
    4、vue 使用指令渲染，react 逻辑运算符；
    5、父子组件传值，vue 使用 props 和 $emit，react 使用 props 和子组件触发父组件的方法，父组件通过setState修改；
    6、路由，vue 路由组件都会渲染到 router-view 里面，react 是全局组件的方式，子组件作为 children 传递到父组件；
    7、vue 实现双向绑定，react 没有；
    8、vue 父组件更新子组件不会动，react 父更新子必更新，需要手动设置；



























